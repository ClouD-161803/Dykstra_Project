\section{Fast-Forwarding Dykstra's Algorithm}
\label{sec:main_result}

% In this section, we propose a modification to Dykstra's algorithm to resolve the stalling problem in the general case.

\subsection{Stalling Formalisation}
Inspired from the discussion of the stalling phenomenon of~\cite{DYKSTRASTALLING}, we identify as a necessary condition for stalling the stationarity of the iterates for successive iteration cycles over $n$ sets. The stalling period is formalised for $n$ half-spaces in Definition~\ref{def:stalling}.

\begin{defn}[Stalling]\label{def:stalling}
Given $m\geq n-1$, a stalling period is defined as those $i\in\lbrace 0,\dots,N_{stall}\rbrace$ with $N_{stall}\geq n$ for which $x_{m+i}=x_{m+i-n}$.
\end{defn}

During stalling, only the auxiliary variables $e_{m+i}$ change, which are modified by constant increments $x_m-x_{m+1}$. The stalling period therefore continues until $e_{m+i}$ becomes such that $x_{m+i}+e_{m-n+i}\in\mathcal{H}_{[m+i]}$. For polyhedral sets, the length of the stalling period can be pre-computed.

\subsection{Stalling Fast-Forwarding} \label{subsec:stalling_fastforward}

To describe the modified algorithm with stalling fast-forwarding, we first establish the length of the staling period as $N_{stall}$. This length can be computed as soon as the algorithm encounters stalling, using the half-spaces that are active at this iteration. The stalling period continues until one of these half-spaces becomes inactive, at which point stalling terminates. This is formalised in Theorem~\ref{thm:nstall}.

\begin{thm}[Length of Stalling Period]\label{thm:nstall}
Suppose that stalling starts at iteration $m$ as in Def.~\ref{def:stalling} and denote the active half-spaces by $\mathcal{A}\coloneqq\set{i\in\lbrace 0,\dots,n-1\rbrace}{x_{m+i}+e_{m-n+i}\not\in\mathcal{H}_{[m+i]}}$. Then, the length of the stalling period is given by
\begin{align}\label{eq:nstall}
N_{stall}\coloneqq\min_{i\in\mathcal{S}} \left(i+\left\lceil k_{m-n+i} / \left(n(c_{[m+i]}-x_{m+i}^T f_{[m+i]})\right)\right\rceil\right),
\end{align}
where $k_{m-n+i}=e_{m-n+i}^T f_{[m+i]}$ and $\mathcal{S}\coloneqq\set{i\in \mathcal{A}}{x_{m-n+i}^T f_{[m+i]} - c_{[m+i]} < 0}$.
\end{thm}

\begin{pf}
Note that the existence of a finite number $N_{stall}$ is a consequence of the Boyle-Dykstra theorem. According to~\eqref{eq:dykstra:proj:poly}, the stalling period will terminate once an active half-space becomes inactive, i.e.\ $x_{m+i}+e_{m-n+i}\in\mathcal{H}_{[m+i]}$ for some $i\geq n$ (Def.~\ref{def:stalling}). According to~\eqref{eq:km}, the only half-spaces that can become inactive are those for which $x_{m+i}^T f_{[m+i]} - c_{[m+i]} < 0$, which is, by definition, a constant during stalling. The length of the stalling period can therefore be obtained from choosing the smallest possible integer $N_i$ for which
\begin{align*}
k_{m-n+i}+n N_i\left(x_{m+i}^T f_{[m+i]} - c_{[m+i]}\right) < 0,\qquad i\in\mathcal{A},
\end{align*}
so that $N_i=\left\lceil k_{m-n+i} / \left(n(c_{[m+i]}-x_{m+i}^T f_{[m+i]})\right)\right\rceil$. If $i_1<\dots<i_j$ are such that $N_{i_1}=\dots = N_{i_j}$, then according to~\eqref{eq:dykstra}, half-space $i_1$ is discarded first (and thus the minimiser of~\eqref{eq:nstall}).\qed
\end{pf}

Following the end of the stalling period, one half-space is discarded from the active half-space and $\mathcal{A}$ redefined, upon which the algorithm may again encounter a stalling condition. By Theorem~\eqref{thm:nstall}, the stalling period can be fast-forwarded by applying constant increments to $k_{m+i}$ for $i=0,\dots,N_{stall}$.

\subsection{Stall-Averse Algorithm} \label{subsec:algo}

We are now ready to describe the of the modified, stall-aware version of Dykstra's algorithm. Our algorithm proceeds identically to the standard Dykstra's algorithm until it detects stalling by checking the stationarity condition $x_m = x_{m-n}$, as per Definition~\ref{def:stalling}. Once stalling is detected at iteration $m$, the algorithm executes its fast-forwarding phase. After performing the standard variable update for the current iteration, it computes the exact number of required stalling iterations, $N_{stall}$, by calling a function that implements Theorem~\ref{thm:nstall}. From this, it determines the number of full $n$-step cycles to skip, $N_{\text{cycles}} \coloneqq \lceil N_{stall} / n \rceil$. For each of the $n$ dual variables $e_j$, the algorithm then computes the constant increment $\Delta k_j = (\trans{f_j} x_{\text{stall}} - c_j)$ and applies a single, large update: $e_j \leftarrow e_j + N_{\text{cycles}} \cdot (\Delta k_j f_j)$. This ``jumps'' the dual variables forward to their state at iteration $m + N_{stall}$. Finally, the main iteration counter $m$ is advanced by $N_{stall}$, effectively skipping the entire stalling period. The proposed implementation is detailed in Algorithm~\ref{alg:fastforward}.

\begin{algorithm}[H]
\caption{Stall-Averse Dykstra's Algorithm}
\label{alg:fastforward}
\begin{algorithmic}[1]
    \Function{DykstraFastForward}{$x^\circ, \{\mathcal{H}_i\}_{i=0}^{n-1}, N_{\max}, \epsilon_{\text{stall}}$}
        \State $x \leftarrow x^\circ$; $e_j \leftarrow 0$ \textbf{for} $j=0, \dots, n-1$; $X_{\text{hist}}[0] \leftarrow x^\circ$; $m \leftarrow 0$ \algcomment{Initialisation}
        \Statex\hrulefill
        \While{$m < N_{\max}$}
            \algcomment{Standard Dykstra's update}
            \State $e_{[m]} \leftarrow x + e_{[m-n]} - \mathcal{P}_{[m]}(x + e_{[m-n]})$
            \State $x \leftarrow x + e_{[m-n]} - e_{[m]}$ 
            \State $X_{\text{hist}}[m+1] \leftarrow x$
            \Statex\hrulefill
            \If{$m \ge n \wedge \twonorm{x - X_{\text{hist}}[m-n]} < \epsilon_{\text{stall}}$} \algcomment{Stalling detected per Def.~\ref{def:stalling}}
                \State $x_{\text{stall}} \leftarrow x$
                \State $N_{stall} \leftarrow \min_{j \in \mathcal{S}} \left(j+\left\lceil k_j / \left(n(c_j - \trans{f_j} x_{\text{stall}})\right)\right\rceil\right)$ \algcomment{Compute using Thm.~\ref{thm:nstall}}
                \State $N_{\text{cycles}} \leftarrow \lceil N_{stall} / n \rceil$
                \For{$j \in \{0, \dots, n-1\}$}
                    \State $k_j \leftarrow \trans{f_j} e_j$ \algcomment{Get scalar from $e_j = k_j f_j$}
                    \State $\Delta k_j \leftarrow \trans{f_j} x_{\text{stall}} - c_j$
                    \State $e_j \leftarrow (k_j + N_{\text{cycles}} \times \Delta k_j) f_j$ \algcomment{Fast-forward dual variable}
                \EndFor
                \State $m \leftarrow m + N_{stall}$ \algcomment{Jump iteration counter}
            \Else
                \State $m \leftarrow m + 1$ \algcomment{Increment iteration counter}
            \EndIf
            \Statex\hrulefill
        \EndWhile
        \State \Return $x$
    \EndFunction
\end{algorithmic}
\end{algorithm}

% \begin{algorithm}[h]
% \caption{Stall-Averse Dykstra's Algorithm}
% \label{alg:fastforward}
% \begin{algorithmic}[1]
%     \Function{DykstraFastForward}{$x^\circ, \{\mathcal{H}_i\}_{i=0}^{n-1}, N_{\max}, \epsilon_{\text{stall}}$}
%         \State $x \leftarrow x^\circ$ \Comment{Initialise iterate}
%         \State $e_j \leftarrow 0$ \textbf{for} $j=0, \dots, n-1$ \Comment{Initialise auxiliary variables}
%         \State $X_{\text{hist}}[0] \leftarrow x^\circ$ \Comment{Initialise history array}
%         \State $m \leftarrow 0$ \Comment{Initialise iteration counter}
%         \Statex\hrulefill
%         \While{$m < N_{\max}$}
%             \State $i \leftarrow m \pmod n$ \Comment{Current half-space index}
%             \State $x_{\text{target}} \leftarrow x + e_i$ \Comment{Using $e_i$ from $m-n$ iterations ago}
%             \State $x_{\text{new}} \leftarrow \mathcal{P}_{\mathcal{H}_i}(x_{\text{target}})$ \Comment{Project using~\eqref{eq:dykstra:proj:poly}}
%             \State $e_i \leftarrow x_{\text{target}} - x_{\text{new}}$ \Comment{Store new error for index $i$}
%             \State $x \leftarrow x_{\text{new}}$
%             \State $X_{\text{hist}}[m+1] \leftarrow x$
%             \State $m \leftarrow m + 1$
%             \Statex\hrulefill
%             \If{$m \ge n \wedge \twonorm{x - X_{\text{hist}}[m-n]} < \epsilon_{\text{stall}}$} \Comment{Stalling detected per Def.~\ref{def:stalling}}
%                 \State $x_{\text{stall}} \leftarrow x$
%                 \State $N_{stall} \leftarrow \min_{j \in \mathcal{S}} \left(j+\left\lceil k_j / \left(n(c_j - \trans{f_j} x_{\text{stall}})\right)\right\rceil\right)$ \Comment{Compute using Thm.~\ref{thm:nstall}}
%                 \State $N_{\text{cycles}} \leftarrow \lceil N_{stall} / n \rceil$
%                 \For{$j \in \{0, \dots, n-1\}$}
%                     \State $k_j \leftarrow \trans{f_j} e_j$ \Comment{Get scalar from $e_j = k_j f_j$}
%                     \State $\Delta k_j \leftarrow \trans{f_j} x_{\text{stall}} - c_j$
%                     \State $e_j \leftarrow (k_j + N_{\text{cycles}} \times \Delta k_j) f_j$ \Comment{Fast-forward dual variable}
%                 \EndFor
%                 \State $m \leftarrow m + N_{stall}$ \Comment{Jump iteration counter}
%             \EndIf
%             \Statex\hrulefill
%         \EndWhile
%         \State \Return $x$
%     \EndFunction
% \end{algorithmic}
% \end{algorithm}

\subsection{Numerical Example} \label{subsec:example}

\begin{figure}[h]
    \centering
    \includegraphics[width=.9\textwidth]{Latex/Current Version/Figures/Stalling_vertical.png}
    \caption{Stalling situation. Standard Dykstra's algorithm applied to a line-box example. (Top): The iterates $x_m$ (blue) start at the original point (blue dot) and project onto each of the half-spaces. The path visibly stalls near the left side of the box before converging to the optimal solution (red star). (Middle): The squared error $E(x_m)$ (red) plateaus during the stalling period (yellow), which lasts from iteration 1 until iteration 16, before converging at iteration 30. (Bottom): Half-space activity. The stalling period ends precisely when half-space 0 (black circles), corresponding to the left side of the box, becomes inactive. Half-space 1 (black squares) and half-space 2 (black triangles) correspond to the top of the box and the line, respectively, and remain active.}
    \label{fig:stalling2}
\end{figure}

% We demonstrate the efficacy of our method through a numerical experiment. The results of our experiment can be reproduced from the repository: \href{https://github.com/ClouD-161803/Dykstra-Project.git}{ClouD-161803/Dykstra-Project}.

We demonstrate the efficacy of our method through a numerical experiment. The results of our experiment can be reproduced from the code repository found in~\cite{DykstraProjectRepo}.

The example we used is the projection of an initial point $x^\circ$ on the intersection of a box and a line in $\mathbb{R}^2$. The box is centered at the origin and can be represented as $[-1, 1] \times [-1, 1]$, and the line passes through the points $[0,1]$ and [-2, 2]. This setup was first described in detail in~\cite[Section 4]{DYKSTRASTALLING}. The initial point was set to $x^\circ = [-4, 1.4]$ to reliably induce the stall, and the ground-truth optimal solution $x^\star$ was computed using the interior-point CQP solver \texttt{quadprog} to serve as a benchmark for error calculations. The convergence behaviour of our proposed algorithm was then monitored via the $\ell_2$ norm of the absolute distance to optimality,
\[
E(x_m) \eqdef \ell_2(x_m - x^\star) = \| x_m - x^\star \|_2^2.
\]
\begin{figure}[h]
    \centering
    \includegraphics[width=.9\textwidth]{Latex/Current Version/Figures/No_stalling_vertical.png}
    \caption{Modified algorithm with fast-forwarding. (Top): Stalling is detected at iteration 1. The algorithm computes $N_{stall}=15$ using Theorem~\ref{thm:nstall} and ``fast-forwards" the iterates, jumping directly to the point where the standard algorithm would have been at iteration 16. Asymptotic convergence follows from iteration 2 onwards. (Middle): The stalling period (yellow) is eliminated. The algorithm ``converges" (green) at iteration 16. (Bottom): Half-space 0 (black circles) becomes inactive immediately after the fast-forward step.}
    \label{fig:fastforwarding}
\end{figure}
Half-space activity was monitored by means of checking~\eqref{eq:sets_i} for each set at each iteration, and we encoded the status of each half space using an indicator function
\[
\mathcal{I}_{\mathcal{H}_i}(x) \eqdef
\begin{cases}
1 & \text{if } x \in \mathcal{H}_i, \\
0 & \text{if } x \notin \mathcal{H}_i.
\end{cases}
\]
The stalling situation using standard Dykstra is illustrated in Figure~\ref{fig:stalling2}. The iterates $x_m$ are plotted in the top plot, the errors $E(x_m)$ in the middle plot and the convergence activity of each of the three initially active half-spaces $\mathcal{I}_{\mathcal{H}_i}(x), i = 0,\dots,2$ (top and left-most half-spaces of the box, and bottom half-space of the line) in the bottom plot. Half-space 0 corresponds to the left side of the box, half-space 1 to the top side of the box, and half-space 2 to the line (with down-facing normal). In Figure~\ref{fig:stalling2}, the algorithm stalls until iteration 16. From the third plot, it can be seen that the stalling period extends until half-space 0 becomes inactive.

Figure~\ref{fig:fastforwarding} illustrates the application of our modified method, using Algorithm~\ref{alg:fastforward}, to the same example, effectively resolving the stalling issue. In Figure~\ref{fig:fastforwarding}, stalling is detected at iteration 1, upon which the algorithm is fast-forwarded using $N_{stall}=15$ iterations, where $N_{stall}$ is computed using Theorem~\ref{thm:nstall}. At iteration 3, the iterates of the modified algorithm arrive where the iterates of the original algorithm arrive at iteration 16. The iterates of the modified algorithm then become identical to those of the original algorithm. It is evident that the modified method achieves superior convergence characteristics when compared to standard Dykstra's algorithm. Although this section has showcased a resolution for a simple example in $p = 2$ dimensions with only three active half-spaces, the results of Theorem~\ref{thm:nstall} and Algorithm~\ref{alg:fastforward} will hold in any number of dimensions and for an arbitrary number of half-spaces. Since the proposed algorithm achieves the same iterates after escaping the stalling period as would be attained with standard Dykstra, the Boyle-Dykstra theorem is retained, thus the iterates are guaranteed to converge to the optimal solution $x^\star$ asymptotically. Our method ensures the iterates converge faster and monotonically after half-space discarding, which enables the practical implementation of Dykstra's algorithm for practitioners.


% \begin{figure}
%     \centering
%     \begin{subfigure}{\textwidth}
%         \centering
%         \includegraphics[width=0.65\textwidth]{Latex/Current Version/Figures/Stalling_vertical.png}
%         \caption{Stalling situation.}
%         \label{fig:stalling2}
%     \end{subfigure}
%     \begin{subfigure}{\textwidth}
%         \centering
%         \includegraphics[width=0.65\textwidth]{Latex/Current Version/Figures/No_stalling_vertical.png}
%         \caption{Modified algorithm with fast-forwarding.}
%         \label{fig:fastforwarding}
%     \end{subfigure}
%     \caption{Dykstra's algorithm applied to a line-box example. The first column illustrates the trajectories of the iterates and their distance to the Euclidean projection computed using an interior point method. The second column shows the half-space activity, where half-space 0 corresponds to the left side of the box, half-space 1 to the top side of the box, and half-space 0 to the line (down-facing normal).}
%     \label{fig:stallingfixed}
% \end{figure}